# Implementation Plan: Feature 002 - Termux Integration

**Feature**: Termux Integration - Terminal Emulator Core
**Status**: Planning Complete
**Created**: 2025-10-21
**Dependencies**: Feature 001 (Android Project Foundation)

---

## Executive Summary

This feature integrates the Termux terminal emulator library to provide ConvoCLI with a full Linux command-line environment. It establishes the foundational backend infrastructure for terminal operations, enabling command execution, process management, and file system interaction on Android.

**Critical Path**: This feature blocks all subsequent terminal functionality (Command Blocks UI, Traditional Terminal Mode, package management).

**Complexity**: High - Requires native code integration (JNI), PTY management, process lifecycle handling, and Android permission coordination.

**Risk Level**: Medium-High - Termux integration has proven stability, but proper lifecycle management and resource cleanup are critical.

---

## Tech Stack Compliance Report
<!-- Auto-generated by SpecSwarm tech stack validation -->

### ✅ Approved Technologies (already in stack)

All technologies required for this feature are pre-approved:

- **Termux Fork** (GPLv3) - Terminal emulator backend
  - Listed in: Termux Integration → Terminal Backend
  - Status: ✅ Approved
  - Purpose: Battle-tested terminal emulation with VT-100/ANSI support

- **JNI to native PTY** (from Termux)
  - Listed in: Termux Integration → PTY Interface
  - Status: ✅ Approved
  - Purpose: Low-level terminal control via POSIX PTY

- **Kotlin Coroutines**
  - Listed in: Architecture Components → Async Operations
  - Status: ✅ Approved
  - Purpose: Asynchronous output streaming and command execution

- **StateFlow / SharedFlow**
  - Listed in: Architecture Components → State Management
  - Status: ✅ Approved
  - Purpose: Reactive terminal output streaming

- **Hilt** 2.48+
  - Listed in: Architecture Components → Dependency Injection
  - Status: ✅ Approved
  - Purpose: Terminal repository injection and lifecycle management

- **Room** 2.6+ (for future command history persistence)
  - Listed in: Data Layer → Local Database
  - Status: ✅ Approved
  - Purpose: Command history storage (future enhancement)

### ➕ New Technologies

**None** - All required technologies are pre-approved.

### ⚠️ Conflicting Technologies

**None detected**

### ❌ Prohibited Technologies

**None used** - Plan adheres to approved stack.

---

## Technical Context

### Integration Approach

**Strategy**: Library integration via Gradle dependency

**Rationale**:
- Termux terminal-emulator library is modular and designed for embedding
- Avoid full app fork to reduce maintenance burden
- Use official releases for stability and security updates
- Custom modifications isolated to integration layer only

**Trade-offs**:
- ✅ **Pro**: Easier updates, smaller codebase, better maintainability
- ✅ **Pro**: Official bug fixes and security patches
- ⚠️ **Con**: Less control over internal terminal behavior
- ⚠️ **Con**: Must work within library's API constraints

### Architecture Pattern

**Pattern**: Repository → ViewModel → UI (Clean Architecture)

```
UI Layer (Compose)
    ↓
ViewModel (State Management)
    ↓
TerminalRepository (Business Logic)
    ↓
Termux TerminalSession (Terminal Backend)
    ↓
Native PTY (JNI) → Shell Process
```

**Flow**:
1. ViewModel requests terminal session from repository
2. Repository creates Termux `TerminalSession` with PTY
3. Session connects to bash shell via native PTY
4. Commands written to PTY stdin
5. Output streamed from PTY stdout/stderr via Flow
6. ViewModel transforms output for UI consumption

### PTY (Pseudo-Terminal) Architecture

**What is PTY?**
A pseudo-terminal provides a bidirectional communication channel between the Android app and a shell process, emulating a physical terminal.

**Components**:
- **PTY Master**: File descriptor owned by ConvoCLI app (read/write)
- **PTY Slave**: File descriptor connected to shell process (stdin/stdout/stderr)
- **Native Implementation**: C code via JNI (provided by Termux)

**Communication Flow**:
```
ConvoCLI App → write() → PTY Master
                             ↓
                         PTY Slave → stdin → bash
bash → stdout/stderr → PTY Slave
                             ↓
                         PTY Master → read() → ConvoCLI App
```

**Responsibilities**:
- Terminal size configuration (rows, columns)
- Character encoding (UTF-8)
- ANSI escape sequence handling (colors, cursor movement)
- Signal forwarding (SIGINT, SIGTERM)

### Session Lifecycle

**Creation**:
1. App requests new session via `TerminalRepository.createSession()`
2. Repository initializes Termux `TerminalSession`
3. Session creates PTY pair (master/slave file descriptors)
4. Session spawns bash process connected to PTY slave
5. Repository returns Flow of output events

**Active State**:
- Commands written to session input
- Output streamed asynchronously via Flow
- Background threads monitor PTY for data
- Session state tracked (RUNNING, STOPPED, ERROR)

**Termination**:
1. User closes terminal or app is destroyed
2. Session sends SIGHUP to shell process
3. PTY file descriptors closed
4. Native resources cleaned up
5. Session marked as STOPPED

**Android Integration**:
- Sessions scoped to Application lifecycle (singleton repository)
- Sessions survive configuration changes (ViewModel retention)
- Sessions paused/resumed on app backgrounding
- Sessions destroyed on app termination

### Environment Setup

**Default Environment Variables**:
```bash
HOME=/data/data/com.convocli/files/home
PATH=/data/data/com.convocli/files/usr/bin:/system/bin
SHELL=/data/data/com.convocli/files/usr/bin/bash
TMPDIR=/data/data/com.convocli/files/usr/tmp
PREFIX=/data/data/com.convocli/files/usr
TERM=xterm-256color
LANG=en_US.UTF-8
```

**Working Directory**:
- **Initial**: `$HOME` (`/data/data/com.convocli/files/home`)
- **Tracking**: Monitor `cd` commands to update current directory
- **Persistence**: Save last working directory to DataStore (future enhancement)

### Error Handling Strategy

**Error Categories**:

1. **Session Initialization Errors**
   - PTY creation failure
   - Shell not found
   - Permission denied
   - **Handling**: Show error dialog, log details, prevent further commands

2. **Command Execution Errors**
   - Invalid command (command not found)
   - Permission denied
   - File not found
   - **Handling**: Display stderr output, continue session

3. **PTY I/O Errors**
   - Broken pipe (process died)
   - Read/write timeout
   - **Handling**: Detect session crash, offer restart

4. **Lifecycle Errors**
   - Session cleanup failure
   - Resource leak
   - **Handling**: Force cleanup, log for debugging

**Error Propagation**:
```kotlin
sealed class TerminalError {
    data class InitializationFailed(val reason: String) : TerminalError()
    data class CommandFailed(val command: String, val exitCode: Int, val stderr: String) : TerminalError()
    data class SessionCrashed(val reason: String) : TerminalError()
    data class IOError(val message: String) : TerminalError()
}

// Emit via SharedFlow
private val _errors = MutableSharedFlow<TerminalError>()
val errors: SharedFlow<TerminalError> = _errors.asSharedFlow()
```

### Performance Considerations

**Output Buffering**:
- Buffer output in 4KB chunks
- Flush to UI at 60fps max (16ms intervals)
- Backpressure handling: Drop frames if UI can't keep up

**Memory Management**:
- Limit output history to 10,000 lines (circular buffer)
- Clear old output when limit exceeded
- Monitor memory usage, trigger GC if needed

**Threading Model**:
- PTY I/O on background thread pool
- Flow collection on IO dispatcher
- UI updates on Main dispatcher via StateFlow

---

## Architecture Decisions

### AD-1: Use Termux as Library Dependency (Not Fork)

**Decision**: Integrate Termux terminal-emulator as a Gradle library dependency, not a forked codebase.

**Context**:
- Termux provides `termux-terminal-emulator` as a standalone library
- Full Termux app fork includes package manager, plugins, UI (not needed)
- ConvoCLI only needs terminal emulation core

**Alternatives Considered**:
1. **Fork entire Termux app**
   - ❌ Too much unnecessary code
   - ❌ Difficult to merge upstream updates
   - ❌ Increases APK size significantly

2. **Write custom terminal emulator**
   - ❌ Extremely complex (VT-100/ANSI specs)
   - ❌ Years of development time
   - ❌ Bugs and compatibility issues

3. **Use Termux as library** ✅ **SELECTED**
   - ✅ Minimal integration surface
   - ✅ Easy upstream updates
   - ✅ Battle-tested reliability
   - ✅ GPLv3 license compatible

**Implications**:
- Must use Termux's API design (low customization)
- Limited control over internal terminal behavior
- Dependency on Termux maintenance (active project, low risk)

**Status**: Approved

### AD-2: Direct PTY Integration (No Abstraction Layer)

**Decision**: Use Termux's native PTY implementation directly via JNI, without custom abstraction.

**Context**:
- PTY is a standardized POSIX interface
- Termux provides stable, optimized JNI bindings
- No benefit to adding abstraction layer

**Alternatives Considered**:
1. **Create custom PTY abstraction**
   - ❌ Adds complexity without benefit
   - ❌ Performance overhead
   - ❌ Maintenance burden

2. **Use Termux PTY directly** ✅ **SELECTED**
   - ✅ Proven stability
   - ✅ Zero overhead
   - ✅ Easy to understand

**Implications**:
- Tightly coupled to Termux PTY implementation
- Must update if Termux changes PTY API (rare)

**Status**: Approved

### AD-3: Kotlin Flow for Output Streaming

**Decision**: Use Kotlin `Flow` for asynchronous terminal output streaming.

**Context**:
- Output can arrive at any time (async)
- UI needs reactive updates
- Backpressure handling required for large outputs

**Alternatives Considered**:
1. **Callbacks**
   - ❌ Callback hell
   - ❌ No backpressure
   - ❌ Hard to test

2. **LiveData**
   - ❌ Deprecated in favor of Flow
   - ❌ Limited operators

3. **Kotlin Flow** ✅ **SELECTED**
   - ✅ Approved in tech stack
   - ✅ Backpressure support
   - ✅ Composable operators (map, filter, debounce)
   - ✅ Lifecycle-aware collection

**Implementation**:
```kotlin
interface TerminalRepository {
    fun createSession(): Result<SessionId>
    fun observeOutput(sessionId: SessionId): Flow<TerminalOutput>
    suspend fun executeCommand(sessionId: SessionId, command: String)
    suspend fun destroySession(sessionId: SessionId)
}

data class TerminalOutput(
    val text: String,
    val stream: StreamType, // STDOUT or STDERR
    val timestamp: Long
)
```

**Status**: Approved

### AD-4: Singleton TerminalRepository with Hilt

**Decision**: Provide `TerminalRepository` as a `@Singleton` via Hilt DI.

**Context**:
- Terminal sessions should be app-wide singletons
- Sessions survive configuration changes
- ViewModels need session access

**Rationale**:
- Hilt is approved DI framework (tech stack)
- `@Singleton` scope ensures one repository instance
- Sessions tied to Application lifecycle
- Easy to inject mocks for testing

**Implementation**:
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object TerminalModule {
    @Provides
    @Singleton
    fun provideTerminalRepository(
        context: Context
    ): TerminalRepository = TermuxTerminalRepository(context)
}
```

**Status**: Approved

### AD-5: Defer Bootstrap Installation to Future Feature

**Decision**: Feature 002 only integrates terminal emulator. Installing the Termux bootstrap environment (apt, packages, etc.) is a separate future feature.

**Context**:
- Bootstrap installation is complex (1000+ packages, 200+ MB download)
- Terminal emulator works with basic shell (bash)
- Can execute simple commands without full bootstrap
- Bootstrap should be user-initiated (not automatic)

**Feature Scope**:
- ✅ **In scope**: Terminal emulator integration, PTY, basic bash shell
- ❌ **Out of scope**: apt package manager, bootstrap installation, package updates

**Future Feature**: "Termux Bootstrap Installation" (Feature 003 or 004)

**Status**: Approved

---

## File Structure

### New Files to Create

```
app/src/main/kotlin/com/convocli/
├── terminal/
│   ├── repository/
│   │   ├── TerminalRepository.kt          # Interface: Terminal operations API
│   │   └── TermuxTerminalRepository.kt    # Implementation: Termux integration
│   │
│   ├── model/
│   │   ├── TerminalSession.kt             # Data class: Session metadata
│   │   ├── TerminalOutput.kt              # Data class: Command output
│   │   ├── TerminalError.kt               # Sealed class: Error types
│   │   └── StreamType.kt                  # Enum: STDOUT, STDERR
│   │
│   ├── service/
│   │   ├── TerminalSessionManager.kt      # Manages active sessions
│   │   └── OutputStreamProcessor.kt       # Processes PTY output stream
│   │
│   └── viewmodel/
│       └── TerminalViewModel.kt           # ViewModel: Terminal UI state
│
├── di/
│   └── TerminalModule.kt                  # Hilt: Terminal DI module
│
└── ui/
    └── terminal/
        └── (Future: Terminal UI components - not in this feature)

app/src/test/kotlin/com/convocli/
├── terminal/
│   ├── repository/
│   │   └── TermuxTerminalRepositoryTest.kt
│   │
│   ├── service/
│   │   └── TerminalSessionManagerTest.kt
│   │
│   └── viewmodel/
│       └── TerminalViewModelTest.kt

app/src/androidTest/kotlin/com/convocli/
├── terminal/
│   └── TerminalIntegrationTest.kt         # Full integration test with PTY

features/002-termux-integration-terminal-emulator-core-for-android-command-execution/
├── spec.md                                 # ✅ Already exists
├── plan.md                                 # ✅ This file
├── research.md                            # Technical research findings
├── data-model.md                          # Data model documentation
├── quickstart.md                          # Development quickstart guide
├── tasks.md                               # Task breakdown (via /tasks)
├── COMPLETION_SUMMARY.md                  # Post-implementation summary
└── checklists/
    └── requirements.md                     # ✅ Already exists
```

### Files to Modify

```
app/build.gradle.kts
├── Add Termux library dependency
├── Configure JNI for native libraries
└── Add Kotlin coroutines test dependencies

app/src/main/AndroidManifest.xml
├── Add READ_EXTERNAL_STORAGE permission (runtime request)
├── Add WRITE_EXTERNAL_STORAGE permission (runtime request)
└── (Future: FOREGROUND_SERVICE for long-running sessions)

app/src/main/kotlin/com/convocli/di/AppModule.kt
└── (No changes needed - TerminalModule is separate)
```

---

## Dependencies

### New Gradle Dependencies

**Termux Terminal Emulator**:
```kotlin
// app/build.gradle.kts
dependencies {
    // Termux terminal emulator library
    implementation("com.termux:termux-shared:0.118.0")
    implementation("com.termux.terminal:terminal-emulator:0.118.0")
    implementation("com.termux.terminal:terminal-view:0.118.0")

    // Already included from Feature 001:
    // - Kotlin Coroutines
    // - Hilt
    // - Room
    // - Compose
}
```

**Note**: Exact version numbers and Maven coordinates will be researched in Phase 0 (research.md).

### Native Libraries

Termux provides pre-compiled native libraries:
- `libterm-emulator.so` (PTY implementation)
- Available for: arm64-v8a, armeabi-v7a, x86, x86_64

**Configuration**:
```kotlin
android {
    defaultConfig {
        ndk {
            abiFilters += listOf("arm64-v8a", "armeabi-v7a", "x86", "x86_64")
        }
    }
}
```

### Android Permissions

**Declared in AndroidManifest.xml**:
```xml
<!-- Storage access for terminal operations -->
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
                 android:maxSdkVersion="28" />

<!-- Scoped storage (API 30+) -->
<uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
                 tools:ignore="ScopedStorage" />
```

**Runtime Request**:
- Request permissions when user attempts to access external storage
- Gracefully handle permission denial
- Provide clear rationale to user

---

## Implementation Phases

### Phase 0: Research & Validation

**Goal**: Resolve technical unknowns and validate approach.

**Tasks**:
1. **Research Termux Library Integration**
   - Find official Maven repository or GitHub releases
   - Determine exact dependency coordinates
   - Verify GPLv3 license compliance
   - Check library API documentation

2. **Validate PTY Implementation**
   - Review Termux PTY source code
   - Understand JNI interface
   - Confirm Android API compatibility (API 26+)

3. **Prototype Basic Integration**
   - Create minimal test app
   - Initialize Termux session
   - Execute simple command (`echo hello`)
   - Verify output capture

4. **Performance Testing**
   - Measure command execution latency
   - Test output streaming with large files (`cat large.txt`)
   - Verify memory usage during extended sessions

5. **Document Findings**
   - Write research.md with decisions and rationale
   - Note any gotchas or limitations discovered
   - Recommend configuration settings

**Deliverable**: `research.md`

### Phase 1: Core Integration

**Goal**: Integrate Termux library and create basic terminal infrastructure.

**Tasks**:

1. **Add Termux Dependencies** (30 min)
   - Update `app/build.gradle.kts` with Termux libraries
   - Configure native library inclusion
   - Sync Gradle, verify compilation

2. **Create Data Models** (1 hour)
   - `TerminalSession.kt`: Session metadata
   - `TerminalOutput.kt`: Output data class
   - `TerminalError.kt`: Error sealed class
   - `StreamType.kt`: STDOUT/STDERR enum

3. **Implement TerminalRepository Interface** (2 hours)
   - Define repository contract
   - Create `TermuxTerminalRepository` implementation
   - Initialize Termux `TerminalSession`
   - Set up PTY with default configuration

4. **Implement Output Streaming** (3 hours)
   - Create `OutputStreamProcessor`
   - Read from PTY master file descriptor
   - Parse ANSI escape sequences (basic)
   - Emit output via `SharedFlow`

5. **Implement Command Execution** (2 hours)
   - Write command to PTY stdin
   - Add newline terminator
   - Handle special characters (escaping)

6. **Create Hilt DI Module** (30 min)
   - `TerminalModule.kt`
   - Provide `@Singleton TerminalRepository`
   - Inject Android `Context`

**Deliverable**: Working terminal backend (no UI yet)

### Phase 2: Session Management

**Goal**: Implement robust session lifecycle management.

**Tasks**:

1. **Session State Tracking** (2 hours)
   - Track session state (RUNNING, STOPPED, ERROR)
   - Implement state transitions
   - Emit state changes via Flow

2. **Environment Configuration** (1 hour)
   - Set default environment variables (HOME, PATH, SHELL)
   - Configure working directory
   - Support custom environment injection

3. **Lifecycle Integration** (3 hours)
   - Handle app backgrounding (pause I/O monitoring)
   - Handle app foregrounding (resume I/O)
   - Survive configuration changes (ViewModel scope)
   - Clean up on app destruction

4. **Error Handling** (2 hours)
   - Detect session crashes (broken pipe)
   - Capture stderr separately from stdout
   - Emit error events via `SharedFlow`
   - Implement retry logic for transient failures

5. **Resource Cleanup** (1 hour)
   - Close PTY file descriptors
   - Terminate shell process (SIGHUP)
   - Cancel coroutines
   - Prevent memory leaks

**Deliverable**: Production-ready session management

### Phase 3: ViewModel Integration

**Goal**: Create ViewModel layer for UI consumption.

**Tasks**:

1. **Create TerminalViewModel** (2 hours)
   - Inject `TerminalRepository` via Hilt
   - Manage UI state with `StateFlow`
   - Collect output from repository
   - Transform output for UI

2. **Implement Command Input Handling** (1 hour)
   - Accept user input
   - Validate input (non-empty)
   - Send to repository
   - Update UI state

3. **Implement Output Display Logic** (1 hour)
   - Buffer output for UI (circular buffer)
   - Limit displayed lines (10,000 max)
   - Handle ANSI color codes (basic parsing)

4. **Error Display** (1 hour)
   - Collect errors from repository
   - Transform to user-friendly messages
   - Emit to UI via `StateFlow`

**Deliverable**: ViewModel ready for UI binding

### Phase 4: Testing

**Goal**: Comprehensive test coverage.

**Tasks**:

1. **Unit Tests** (4 hours)
   - `TermuxTerminalRepositoryTest`: Mock Termux session
   - `TerminalSessionManagerTest`: State transitions
   - `TerminalViewModelTest`: UI state logic

2. **Integration Tests** (3 hours)
   - `TerminalIntegrationTest`: Full session lifecycle
   - Execute real commands on emulator
   - Verify output correctness
   - Test error scenarios

3. **Performance Tests** (2 hours)
   - Measure command execution latency
   - Test with large output (10,000 lines)
   - Monitor memory usage
   - Verify no memory leaks (LeakCanary)

4. **Edge Case Testing** (2 hours)
   - Invalid commands
   - Rapid command execution
   - Special characters in commands
   - Binary output handling

**Deliverable**: 80%+ test coverage

### Phase 5: Documentation

**Goal**: Complete feature documentation.

**Tasks**:

1. **Data Model Documentation** (1 hour)
   - Write `data-model.md`
   - Document entities and relationships
   - Include state diagrams

2. **Developer Quickstart** (1 hour)
   - Write `quickstart.md`
   - Setup instructions
   - Basic usage examples
   - Troubleshooting guide

3. **Code Documentation** (2 hours)
   - KDoc comments for all public APIs
   - Usage examples in comments
   - Architecture decision records (ADRs)

4. **Completion Summary** (1 hour)
   - Write `COMPLETION_SUMMARY.md`
   - Feature retrospective
   - Lessons learned
   - Future improvements

**Deliverable**: Complete documentation package

---

## Testing Strategy

### Unit Testing

**Scope**: Individual components in isolation

**Framework**: JUnit 4 + Kotlin Test + Turbine (Flow testing)

**Test Cases**:

1. **TermuxTerminalRepositoryTest**
   ```kotlin
   @Test
   fun `createSession returns success with valid configuration`()

   @Test
   fun `executeCommand writes to PTY stdin`()

   @Test
   fun `observeOutput emits terminal output events`()

   @Test
   fun `destroySession cleans up resources`()
   ```

2. **TerminalViewModelTest**
   ```kotlin
   @Test
   fun `viewModel initializes terminal session on creation`()

   @Test
   fun `executeCommand updates UI state with output`()

   @Test
   fun `handleError displays user-friendly error message`()
   ```

**Mocking Strategy**:
- Mock Termux `TerminalSession` (interface wrapper)
- Fake PTY I/O (in-memory streams)
- No real processes in unit tests

### Integration Testing

**Scope**: Full terminal session lifecycle with real PTY

**Framework**: AndroidX Test + JUnit 4

**Test Cases**:

1. **TerminalIntegrationTest**
   ```kotlin
   @Test
   fun `executes simple command and captures output`() {
       val session = repository.createSession().getOrThrow()
       repository.executeCommand(session, "echo hello")

       val output = repository.observeOutput(session).first()
       assertEquals("hello", output.text.trim())
   }

   @Test
   fun `handles command errors gracefully`() {
       val session = repository.createSession().getOrThrow()
       repository.executeCommand(session, "invalidcommand")

       val error = repository.errors.first()
       assertTrue(error is TerminalError.CommandFailed)
   }

   @Test
   fun `session survives configuration changes`() {
       // Simulate rotation
       activityRule.scenario.recreate()

       // Session should still be active
       assertTrue(viewModel.isSessionActive())
   }
   ```

**Environment**:
- Run on Android emulator (API 26+)
- Real Termux library (not mocked)
- Real PTY and shell processes

### Performance Testing

**Scope**: Latency, throughput, memory usage

**Metrics**:
- Command execution latency < 200ms
- Output streaming latency < 100ms
- Memory usage < 50MB during streaming
- No memory leaks after 1000 commands

**Test Cases**:

```kotlin
@Test
fun `command execution completes within 200ms`() {
    val startTime = System.currentTimeMillis()
    repository.executeCommand(session, "echo test")
    val output = repository.observeOutput(session).first()
    val duration = System.currentTimeMillis() - startTime

    assertTrue(duration < 200)
}

@Test
fun `handles 10000 lines without memory leak`() {
    LeakCanary.install()

    repository.executeCommand(session, "seq 1 10000")
    repository.observeOutput(session).take(10000).collect()

    // Trigger GC and check for leaks
    Runtime.getRuntime().gc()
    assertNoLeaks()
}
```

### Manual Testing Checklist

**Functional Tests**:
- [ ] Execute simple commands (ls, pwd, echo)
- [ ] Navigate directories (cd, pwd)
- [ ] View file contents (cat, less)
- [ ] Run complex commands (pipes, redirects)
- [ ] Handle invalid commands gracefully
- [ ] Capture stderr separately from stdout

**Lifecycle Tests**:
- [ ] Session survives device rotation
- [ ] Session persists when app backgrounded
- [ ] Session cleaned up on app termination
- [ ] Multiple sequential sessions work correctly

**Performance Tests**:
- [ ] Commands respond instantly (< 200ms)
- [ ] Large outputs stream smoothly (10,000 lines)
- [ ] No UI freezing during command execution
- [ ] Memory usage remains stable

**Edge Cases**:
- [ ] Binary output (non-UTF8)
- [ ] Rapid command execution (stress test)
- [ ] Long-running commands (sleep 60)
- [ ] Commands with special characters

---

## Constitution Check

*Evaluating this plan against project constitution principles...*

### Principle 1: Architectural Integrity ✅ **COMPLIANT**

**Guideline**: Follow established patterns (MVI, Clean Architecture, Repository pattern)

**Compliance**:
- ✅ Repository pattern for terminal operations
- ✅ ViewModel for UI state management
- ✅ StateFlow for reactive updates
- ✅ Hilt for dependency injection
- ✅ Separation of concerns (data, domain, presentation)

**Evidence**: Architecture follows Feature 001 patterns precisely.

### Principle 2: Code Quality ✅ **COMPLIANT**

**Guideline**: ktlint formatting, comprehensive testing, documentation

**Compliance**:
- ✅ All code will be ktlint-compliant
- ✅ 80%+ test coverage target (unit + integration)
- ✅ KDoc for all public APIs
- ✅ Comprehensive documentation (data-model.md, quickstart.md)

**Evidence**: Testing strategy includes unit, integration, and performance tests.

### Principle 3: User Experience ✅ **COMPLIANT**

**Guideline**: Responsive, intuitive, accessible

**Compliance**:
- ✅ Commands execute in < 200ms (success criterion)
- ✅ Output streams without UI freezing
- ✅ Error messages are user-friendly
- ✅ Graceful degradation (permission denial handling)

**Evidence**: Performance targets defined in success criteria.

### Principle 4: Data Integrity ✅ **COMPLIANT**

**Guideline**: Validate inputs, handle errors, prevent data loss

**Compliance**:
- ✅ Command input validation (non-empty check)
- ✅ Comprehensive error handling (4 error categories)
- ✅ Session state tracking prevents invalid operations
- ✅ Resource cleanup prevents leaks

**Evidence**: Error handling strategy covers all failure modes.

### Principle 5: Technology Consistency ✅ **COMPLIANT**

**Guideline**: Adhere to approved tech stack, justify deviations

**Compliance**:
- ✅ All technologies pre-approved in tech-stack.md
- ✅ Termux: ✅ Approved
- ✅ Kotlin Coroutines: ✅ Approved
- ✅ Hilt: ✅ Approved
- ✅ StateFlow: ✅ Approved
- ✅ Room (future): ✅ Approved

**Evidence**: Tech Stack Compliance Report shows zero conflicts, zero prohibited tech.

### Principle 6: Security & Privacy ✅ **COMPLIANT**

**Guideline**: Secure data, request minimal permissions, protect user privacy

**Compliance**:
- ✅ Permissions requested at runtime (not install-time)
- ✅ Storage access only when needed (user-initiated)
- ✅ No network access (offline-first)
- ✅ No telemetry or analytics
- ✅ GPLv3 license respected

**Evidence**: Permission strategy documented in Dependencies section.

### Principle 7: Performance ✅ **COMPLIANT**

**Guideline**: Optimize for speed, minimize resource usage

**Compliance**:
- ✅ Async operations via coroutines (non-blocking)
- ✅ Output buffering prevents excessive UI updates
- ✅ Memory limits enforced (10,000 line history)
- ✅ Performance testing in Phase 4

**Evidence**: Performance considerations section defines optimization strategies.

### Principle 8: Maintainability ✅ **COMPLIANT**

**Guideline**: Clear code, comprehensive docs, easy to modify

**Compliance**:
- ✅ Clean Architecture (easy to swap implementations)
- ✅ Interface-based design (TerminalRepository)
- ✅ Comprehensive documentation
- ✅ KDoc comments for all APIs
- ✅ Testing enables refactoring

**Evidence**: File structure shows clear separation of concerns.

### Principle 9: Scalability ✅ **COMPLIANT**

**Guideline**: Design for growth, support future features

**Compliance**:
- ✅ Repository pattern allows multiple session support (future)
- ✅ Flow-based API supports backpressure
- ✅ Session lifecycle enables background execution (future Foreground Service)
- ✅ Modular design (terminal backend separate from UI)

**Evidence**: AD-5 defers bootstrap to future feature (phased approach).

### Principle 10: Open Source Excellence ✅ **COMPLIANT**

**Guideline**: GPLv3 compliance, transparent development

**Compliance**:
- ✅ Termux library is GPLv3
- ✅ ConvoCLI is GPLv3 (compatible)
- ✅ License attribution documented
- ✅ Source modifications tracked separately
- ✅ Feature documented in public repo

**Evidence**: AD-1 discusses license compatibility.

---

## Summary

**Overall Constitution Compliance**: ✅ **100% COMPLIANT**

All 10 constitutional principles are satisfied. This feature maintains architectural integrity, code quality, and user experience standards established in Feature 001.

**Constitutional Risks**: **None identified**

**Recommended Actions**: Proceed to implementation phase.

---

## Risk Assessment

### Technical Risks

**Risk 1: Termux Library API Changes**
- **Probability**: Low
- **Impact**: Medium
- **Mitigation**: Pin to stable version, monitor upstream changes, use repository pattern for easy swap

**Risk 2: PTY Reliability Across Android Versions**
- **Probability**: Low (Termux proven on API 26+)
- **Impact**: High
- **Mitigation**: Test on multiple Android versions, fallback to basic shell if PTY fails

**Risk 3: Memory Leaks from Native Code**
- **Probability**: Medium
- **Impact**: High
- **Mitigation**: Comprehensive testing with LeakCanary, proper JNI cleanup, resource tracking

**Risk 4: Performance Degradation with Large Outputs**
- **Probability**: Medium
- **Impact**: Medium
- **Mitigation**: Output buffering, circular buffer limits, backpressure handling

### Integration Risks

**Risk 5: Hilt Injection Complexity**
- **Probability**: Low (Hilt is mature)
- **Impact**: Low
- **Mitigation**: Follow Hilt best practices from Feature 001

**Risk 6: Lifecycle Management Errors**
- **Probability**: Medium
- **Impact**: Medium
- **Mitigation**: Extensive lifecycle testing, ViewModel scope management

### Deployment Risks

**Risk 7: Permission Denial by Users**
- **Probability**: High (users cautious about storage access)
- **Impact**: Medium
- **Mitigation**: Clear rationale, graceful degradation, work within app sandbox

**Risk 8: APK Size Increase**
- **Probability**: High (native libs for 4 architectures)
- **Impact**: Low (acceptable for terminal app)
- **Mitigation**: Monitor APK size, use APK splits if needed (future)

---

## Next Steps

### Immediate Actions

1. **Review this plan** with stakeholder/user
2. **Execute Phase 0** (Research):
   - `/specswarm:research` or manual research
   - Create `research.md`
3. **Execute Phase 1** (Design):
   - Create `data-model.md`
   - Generate contracts (if needed)
   - Write `quickstart.md`
4. **Break down tasks**:
   - Run `/specswarm:tasks` to generate detailed task list
5. **Begin implementation**:
   - Run `/specswarm:implement` or implement manually

### Post-Implementation

1. **Validate against success criteria** (spec.md)
2. **Complete PRE_MERGE_CHECKLIST.md**
3. **Write COMPLETION_SUMMARY.md**
4. **Run `/specswarm:complete`** to merge feature

---

## Appendix

### Glossary

**PTY (Pseudo-Terminal)**: A software abstraction that emulates a physical terminal, providing bidirectional communication between an application and a shell process.

**ANSI Escape Codes**: Special character sequences that control text formatting (color, bold, cursor position) in terminal output.

**JNI (Java Native Interface)**: Technology allowing Java/Kotlin code to call native C/C++ code.

**File Descriptor (FD)**: Integer handle representing an open file, pipe, or device in Unix/Linux.

**POSIX**: Portable Operating System Interface - standards for Unix-like systems.

**Session**: An active instance of a terminal with a running shell process.

**VT-100**: Classic terminal emulation standard, widely supported.

### References

- [Termux GitHub](https://github.com/termux/termux-app)
- [Termux Wiki](https://wiki.termux.com/)
- [POSIX PTY Documentation](https://man7.org/linux/man-pages/man7/pty.7.html)
- [Android JNI Guide](https://developer.android.com/training/articles/perf-jni)
- [Kotlin Flow Documentation](https://kotlinlang.org/docs/flow.html)
- [Hilt Documentation](https://dagger.dev/hilt/)

### Related Features

- **Feature 001**: Android Project Foundation Setup (dependency)
- **Feature 003**: Command Execution UI (builds on this feature)
- **Feature 004**: Command Blocks UI (builds on this feature)
- **Feature 005**: Traditional Terminal Mode (builds on this feature)

---

**Plan Status**: ✅ **Complete and Ready for Implementation**

**Next Command**: `/specswarm:tasks` to break down into actionable tasks
